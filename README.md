# **TermCraft: 形式系统解谜游戏 - 玩家与关卡设计手册**

### **1. 游戏概述**

*   **一句话简介**: `TermCraft`是一款基于形式系统（formal system）的解谜游戏，玩家通过应用重写规则和构造新结构，将一个初始的符号表达式（“项”）变换为指定的目标形态。
*   **游戏目标**: 玩家的最终目标是在有限的资源（燃料和预算）内，通过一系列合法的操作，将屏幕上方的“当前项 (Current Term)”精确地变换成与“目标项 (Target Term)”完全一致的结构。

### **2. 核心玩法与机制**

##### **2.1 理解“项 (Term)”**

游戏中的所有事物都由“项”构成。一个项是一种精确的、树状的数据结构。你可以将整个游戏世界看作一棵巨大的、不断变化的“项之树”。项有三种基本类型：

*   **常量 (Constant)**: 最基础的构建块，代表一个固定的值。例如：`apple`, `green`, `placeholder`。
*   **变量 (Variable)**: 在规则中作为“通配符”使用，可以匹配任意的项。格式总是 `var(NAME)`。例如：`var(X)`, `var(AnyTerm)`。
*   **复合项 (Compound Term)**: 由一个构造函数名称和零个或多个子项组成，用于构建更复杂的结构。格式为 `name(child1, child2, ...)`。例如：`pair(apple, green)`。

##### **2.2 关键资源**

*   **燃料 (Fuel)**: 你的主要行动力。每当你执行一次“重写”动作时，都会消耗1点燃料。燃料一旦耗尽，你将无法再执行重写，游戏可能会因此失败。
*   **预算 (Budget)**: 用于创造新事物的资源。当你执行“构造”动作来填充一个占位符时，会消耗预算。消耗量等于你构造的新项的“代价”。

##### **2.3 玩家的动作**

*   **动作一：重写 (Rewrite)**:
    *   游戏世界中包含形如 `rewrite(L, R)` 的规则项。`L` (Left-Hand Side) 是一个模式，`R` (Right-Hand Side) 是替换结果。
    *   当“当前项”的某个部分与规则的 `L` 部分成功匹配时，你就可以执行一次重写，将匹配部分替换为 `R`。
    *   游戏中还可能存在 `equiv(A, B)` 这样的等价公理，它会让你在匹配 `L` 时，可以将 `A` 当作 `B` 来看待（反之亦然），从而发现更多重写机会。
    *   **代价**: 每次重写消耗 **1** 点燃料。

*   **动作二：构造 (Construct)**:
    *   游戏世界中存在名为 `placeholder` 的特殊常量。它们在界面上高亮显示，代表可以填充新内容的地方。
    *   点击一个 `placeholder`，你可以输入一个全新的项来替换它。
    *   **代价**: 构造会消耗预算。新项的“代价”不能超过你当前剩余的预算。代价的计算方式详见 3.4 节。

##### **2.4 胜利与失败**

*   **胜利条件**: 当“当前项”的结构与“目标项”完全一致时，你将获得胜利。
*   **失败条件**:
    *   燃料耗尽，且无法通过构造新项来继续游戏。
    *   没有任何可执行的重写或构造动作，陷入死局。

### **3. 开发者模式与关卡设计指南 (高级)**

##### **3.1 开启方式与面板概览**

点击游戏界面右上角的 **“开发者模式”** 按钮即可开启设置面板。你可以在此定义一个全新的关卡。

| 字段名称 | HTML ID | 说明 |
| :--- | :--- | :--- |
| 燃料 (Fuel) | `dev-fuel-input` | 关卡的初始燃料值。 |
| 预算 (Budget) | `dev-budget-input` | 关卡的初始预算值。 |
| 当前项 | `dev-current-term-input` | 关卡的初始状态，以项的文本格式输入。 |
| 目标项 | `dev-target-term-input` | 关卡的胜利条件，以项的文本格式输入。 |
| 应用设置 | `dev-apply-button` | 点击此按钮，用以上设置加载新关卡。 |

##### **3.2 “项”的通用语法规则**

*   **分析来源**: 以下所有语法规则均由游戏引擎的 `Term.fromString(str)` 解析函数严格定义。
*   **语法细则**:
    *   **常量 (Constant)**:
        *   **格式**: 由字母、数字和下划线组成的单个词。
        *   **规则**: 不能包含括号或逗号，除非它们是整个名称的一部分（不推荐）。
        *   **示例**: `apple`, `my_const`, `state1`

    *   **变量 (Variable)**:
        *   **格式**: `var(Name)`
        *   **规则**: `var` 关键字本身不区分大小写，但括号和内部的变量名 `Name` 是必需的。`Name` 遵循与常量相同的命名规则。
        *   **示例**: `var(X)`, `var(Anything)`

    *   **复合项 (Compound Term)**:
        *   **格式**: `name(argument1, argument2, ...)`
        *   **规则**:
            *   以构造函数名称开头，后跟一对括号。
            *   括号内是零个或多个子项（参数），以逗号 `,` 分隔。
            *   子项可以是任何合法的项类型（常量、变量、其他复合项），允许无限嵌套。
            *   构造函数名称遵循与常量相同的命名规则。
            *   零参数的复合项格式为 `name()`。
        *   **示例**: `pair(apple, green)`, `rule(var(X), var(X))`, `empty_list()`

##### **3.3 核心构造函数详解**

**引言**: 在TermCraft中，大多数复合项的名称只起到组织数据的作用。然而，有几个特殊的名称是游戏引擎的‘关键字’，它们会触发核心的游戏机制。理解它们的区别是设计关卡的关键。

**3.3.1 机制驱动型构造函数 (Engine Keywords)**

**一、 重写规则：`rewrite`**
*   **结构**: `rewrite(LHS, RHS)`
*   **作用**: 定义一条核心的重写规则。这是玩家可以主动选择并执行的主要动作。游戏引擎会扫描所有 `rewrite` 项来生成“可用动作”列表。
*   **参数**:
    *   `LHS` (Left-Hand Side): 一个作为“模式”的项。它可以包含变量。
    *   `RHS` (Right-Hand Side): 一个作为“替换结果”的项。
*   **机制**: 当玩家选择应用此规则，并且游戏中的某个地方（应用点）能与 `LHS` 匹配时，该应用点就会被替换为代入变量后的 `RHS`。此操作消耗1点燃料。
*   **示例**: `rewrite(pair(var(X), var(Y)), rev_pair(var(Y), var(X)))`

**二、 等价公理：`equiv`**
*   **结构**: `equiv(TermA, TermB)`
*   **作用**: 定义一条等价公理，声明两个项是等价的。这本身不是一个主动动作，而是影响 `rewrite` 规则匹配方式的背景条件。
*   **参数**:
    *   `TermA`, `TermB`: 两个被视为等价的、不含变量的“基项 (Ground Term)”。
*   **机制**: 在尝试将 `rewrite` 规则的 `LHS` 与游戏中的项进行匹配时，如果 `TermA` 出现在匹配位置，引擎会认为 `TermB` 也在那里（反之亦然），从而发现更多可能的匹配。
*   **示例**: `equiv(apple, red)`

**3.3.2 结构/数据型构造函数 (Data Constructors)**

*   **说明**: 以下是在示例关卡中出现的、用于组织游戏状态的构造函数。它们本身没有特殊的内置逻辑，你可以自定义任何你喜欢的名称来构建关卡的数据结构。
*   **示例分析**:
    *   **`puzzle_state(...)`**: 作为包裹整个游戏状态（规则、公理、数据）的根节点，便于管理。
    *   **`data(...)`**: 用于标记那些代表“状态”而非“规则”的项，纯粹为了关卡设计的可读性。
    *   **`pair(...)`, `rev_pair(...)`**: 纯粹的数据结构，用于演示规则如何作用于数据。

**3.3.3 特殊常量**

*   **`placeholder`**:
    *   **类型**: 常量 (Constant Term)
    *   **作用**: 在游戏界面上表现为一个可点击的“占位符”，允许玩家执行“构造”动作。
    *   **机制**: 点击后会弹出一个模态框，让玩家输入一个新的项来替换它。新项的“代价”不能超过剩余的“预算”。

##### **3.4 资源计算机制**

*   **分析来源**: 资源消耗逻辑由 `ApplyAction` 函数处理，而构造代价由 `Size(T)` 函数严格定义。
*   **燃料 (Fuel)**: 每次成功执行一个 `rewrite` 动作，固定消耗 **1** 点燃料。
*   **预算 (Budget) 与 项的代价 (Cost)**:
    *   构造新项时消耗的预算等于该项的“代价”。代价由 `Size(T)` 函数递归计算：
        1.  **基础代价**: 任何项（常量、变量）的基础代价为 **1**。
        2.  **复合代价**: 一个复合项的代价等于 **1** (为其自身的构造函数) **加上** 其所有子项的代价之和。
    *   **计算示例**:
        *   `cost(apple)` = 1
        *   `cost(var(X))` = 1
        *   `cost(pair(apple, green))`
            *   = 1 (for `pair`) + cost(`apple`) + cost(`green`)
            *   = 1 + 1 + 1 = **3**
        *   `cost(rewrite(var(X), apple))`
            *   = 1 (for `rewrite`) + cost(`var(X)`) + cost(`apple`)
            *   = 1 + 1 + 1 = **3**

##### **3.5 应用与注意事项**

*   **应用设置**: 在开发者面板中完成所有设置后，必须点击 **“应用设置”** 按钮来加载你的关卡。
*   **格式化**: 在“当前项”和“目标项”的输入框中，你可以使用**换行和空格**来格式化你的代码，使其更易读。引擎在解析前会自动移除所有空白字符。
*   **语法错误**: 无效的项语法会导致关卡加载失败。请仔细检查你的括号是否匹配、逗号是否正确使用。错误信息会显示在“应用设置”按钮旁边。
